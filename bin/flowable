#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'json'
require 'yaml'
require_relative '../lib/flowable'

module FlowableCLI
  class CLI
    CONFIG_FILE = File.expand_path('~/.flowable.yml')

    def initialize
      @options = load_config
    end

    def run(args)
      return show_help if args.empty?

      command = args.shift
      case command
      when 'config'
        configure(args)
      when 'deploy'
        deploy(args)
      when 'definitions', 'defs'
        definitions(args)
      when 'start'
        start_case(args)
      when 'cases'
        list_cases(args)
      when 'case'
        show_case(args)
      when 'tasks'
        list_tasks(args)
      when 'task'
        show_task(args)
      when 'claim'
        claim_task(args)
      when 'complete'
        complete_task(args)
      when 'vars'
        show_variables(args)
      when 'set'
        set_variable(args)
      when 'history'
        show_history(args)
      when 'process-start'
        start_process(args)
      when 'processes'
        list_processes(args)
      when 'help', '-h', '--help'
        show_help
      else
        puts "Unknown command: #{command}"
        show_help
        exit 1
      end
    rescue Flowable::Error => e
      puts "Error: #{e.message}"
      exit 1
    end

    private

    def client
      @client ||= Flowable::Client.new(
        host: @options[:host] || 'localhost',
        port: @options[:port] || 8080,
        username: @options[:username] || 'rest-admin',
        password: @options[:password] || 'test',
        use_ssl: @options[:use_ssl] || false
      )
    end

    def load_config
      return {} unless File.exist?(CONFIG_FILE)

      YAML.load_file(CONFIG_FILE, symbolize_names: true) || {}
    rescue StandardError
      {}
    end

    def save_config
      File.write(CONFIG_FILE, @options.to_yaml)
      puts "Config saved to #{CONFIG_FILE}"
    end

    # === Commands ===

    def configure(args)
      opts = OptionParser.new do |o|
        o.banner = 'Usage: flowable config [options]'
        o.on('--host HOST', 'Flowable host') { |v| @options[:host] = v }
        o.on('--port PORT', Integer, 'Flowable port') { |v| @options[:port] = v }
        o.on('--username USER', 'Username') { |v| @options[:username] = v }
        o.on('--password PASS', 'Password') { |v| @options[:password] = v }
        o.on('--ssl', 'Use HTTPS') { @options[:use_ssl] = true }
        o.on('--show', 'Show current config') do
          puts 'Current configuration:'
          puts "  Host: #{@options[:host] || 'localhost'}"
          puts "  Port: #{@options[:port] || 8080}"
          puts "  Username: #{@options[:username] || 'rest-admin'}"
          puts "  SSL: #{@options[:use_ssl] || false}"
          exit 0
        end
      end
      opts.parse!(args)
      save_config
    end

    def deploy(args)
      if args.empty?
        puts 'Usage: flowable deploy <file.cmmn.xml|file.bpmn.xml> [--tenant TENANT]'
        exit 1
      end

      file_path = args.shift
      tenant_id = nil

      opts = OptionParser.new do |o|
        o.on('--tenant TENANT', 'Tenant ID') { |v| tenant_id = v }
      end
      opts.parse!(args)

      unless File.exist?(file_path)
        puts "File not found: #{file_path}"
        exit 1
      end

      # Determine if CMMN or BPMN based on extension
      if file_path.include?('.cmmn')
        result = client.deployments.create(file_path, tenant_id: tenant_id)
        puts 'CMMN Deployment created:'
      else
        result = client.bpmn_deployments.create(file_path, tenant_id: tenant_id)
        puts 'BPMN Deployment created:'
      end

      puts "  ID: #{result['id']}"
      puts "  Name: #{result['name']}"
      puts "  Time: #{result['deploymentTime']}"
    end

    def definitions(args)
      type = 'cmmn'
      opts = OptionParser.new do |o|
        o.banner = 'Usage: flowable definitions [options]'
        o.on('--bpmn', 'Show BPMN process definitions') { type = 'bpmn' }
        o.on('--cmmn', 'Show CMMN case definitions (default)') { type = 'cmmn' }
      end
      opts.parse!(args)

      if type == 'bpmn'
        result = client.process_definitions.list
        puts "Process Definitions (#{result['total']}):"
      else
        result = client.case_definitions.list
        puts "Case Definitions (#{result['total']}):"
      end
      result['data'].each do |d|
        puts "  #{d['key']} v#{d['version']} - #{d['name']} [#{d['id']}]"
      end
    end

    def start_case(args)
      if args.empty?
        puts 'Usage: flowable start <caseKey> [--var key=value ...] [--business-key KEY]'
        exit 1
      end

      case_key = args.shift
      variables = {}
      business_key = nil

      opts = OptionParser.new do |o|
        o.on('--var VAR', 'Variable (key=value)') do |v|
          key, value = v.split('=', 2)
          variables[key.to_sym] = parse_value(value)
        end
        o.on('--business-key KEY', 'Business key') { |v| business_key = v }
      end
      opts.parse!(args)

      result = client.case_instances.start_by_key(
        case_key,
        variables: variables,
        business_key: business_key
      )

      puts 'Case started:'
      puts "  ID: #{result['id']}"
      puts "  State: #{result['state']}"
      puts "  Definition: #{result['caseDefinitionName']}"
    end

    def start_process(args)
      if args.empty?
        puts 'Usage: flowable process-start <processKey> [--var key=value ...] [--business-key KEY]'
        exit 1
      end

      process_key = args.shift
      variables = {}
      business_key = nil

      opts = OptionParser.new do |o|
        o.on('--var VAR', 'Variable (key=value)') do |v|
          key, value = v.split('=', 2)
          variables[key.to_sym] = parse_value(value)
        end
        o.on('--business-key KEY', 'Business key') { |v| business_key = v }
      end
      opts.parse!(args)

      result = client.process_instances.start_by_key(
        process_key,
        variables: variables,
        business_key: business_key
      )

      puts 'Process started:'
      puts "  ID: #{result['id']}"
      puts "  Ended: #{result['ended']}"
      puts "  Definition: #{result['processDefinitionId']}"
    end

    def list_cases(args)
      filters = {}
      opts = OptionParser.new do |o|
        o.banner = 'Usage: flowable cases [options]'
        o.on('--key KEY', 'Filter by case definition key') { |v| filters[:caseDefinitionKey] = v }
        o.on('--business-key KEY', 'Filter by business key') { |v| filters[:businessKey] = v }
      end
      opts.parse!(args)

      result = client.case_instances.list(**filters)
      puts "Case Instances (#{result['total']}):"
      result['data'].each do |c|
        puts "  [#{c['state']}] #{c['id']} - #{c['caseDefinitionName']} (#{c['businessKey'] || 'no business key'})"
      end
    end

    def list_processes(args)
      filters = {}
      opts = OptionParser.new do |o|
        o.banner = 'Usage: flowable processes [options]'
        o.on('--key KEY', 'Filter by process definition key') { |v| filters[:processDefinitionKey] = v }
        o.on('--business-key KEY', 'Filter by business key') { |v| filters[:businessKey] = v }
      end
      opts.parse!(args)

      result = client.process_instances.list(**filters)
      puts "Process Instances (#{result['total']}):"
      result['data'].each do |p|
        status = if p['suspended']
                   'SUSPENDED'
                 else
                   (p['ended'] ? 'ENDED' : 'ACTIVE')
                 end
        puts "  [#{status}] #{p['id']} - #{p['processDefinitionId']} (#{p['businessKey'] || 'no business key'})"
      end
    end

    def show_case(args)
      if args.empty?
        puts 'Usage: flowable case <caseInstanceId>'
        exit 1
      end

      case_id = args.shift
      result = client.case_instances.get(case_id)

      puts "Case Instance: #{result['id']}"
      puts "  Name: #{result['name']}"
      puts "  State: #{result['state']}"
      puts "  Definition: #{result['caseDefinitionName']}"
      puts "  Business Key: #{result['businessKey']}"
      puts "  Start Time: #{result['startTime']}"
      puts "  Start User: #{result['startUserId']}"

      # Show stages
      stages = client.case_instances.stage_overview(case_id) rescue []
      unless stages.empty?
        puts "\n  Stages:"
        stages.each do |stage|
          status = if stage['current']
                     'â–¶'
